<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MUON AI - User Portal</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles.css" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');

/* 
    body {
      cursor: none; /* Hide default cursor */
    /* } */ 

    /* Custom cursor styles */
    #custom-cursor {
      position: fixed;
      left: 0;
      top: 0;
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .cursor-circle {
      width: 20px;
      height: 20px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease-out, background 0.3s ease-out;
    }

    .cursor-dot {
      width: 6px;
      height: 6px;
      background: #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }

    .cursor-active .cursor-circle {
      transform: translate(-50%, -50%) scale(1.5);
      background: rgba(255, 255, 255, 0.7);
    }
    /* Particle Grid Canvas */
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }
  </style>
</head>
<body class="bg-black text-gray-200">

    <header class="fixed top-0 left-0 right-0 p-6 z-50">
        <nav class="glass-container flex justify-between items-center px-8 py-4 max-w-7xl mx-auto">
          <div class="flex items-center space-x-2">
            <i class="fa-solid fa-sparkle fa-2xl" style="color: #ffffff;"></i>
            <a href="index.html" class="text-xl font-bold text-gray-200">MUON AI</a>
          </div>
          <div class="flex space-x-6 text-gray-400">
            <a href="index.html" class="hover:text-white transition-colors duration-300">Home</a>
            <a href="operator.html" class="hover:text-white transition-colors duration-300">Operator Portal</a>
            <a href="user.html" class="hover:text-white transition-colors duration-300">User Portal</a>
          </div>
        </nav>
      </header>

  <canvas id="particleCanvas"></canvas>

  <main class="relative py-20 px-6 bg-transparent text-gray-200 z-10">
    <div class="max-w-4xl mx-auto">
      <div class="text-center mb-12">
        <h1 class="text-4xl md:text-5xl font-bold">Your Resilience Dashboard</h1>
        <p class="text-lg text-gray-400 mt-2">Personalized alerts for a prepared future.</p>
      </div>

      <section class="mb-8">
        <div class="glass-container p-6 md:p-8 flex flex-col md:flex-row items-center justify-between">
          <div class="flex items-center space-x-4">
            <div id="alert-status-icon" class="w-16 h-16 rounded-full flex items-center justify-center">
              </div>
            <div>
              <p class="text-lg text-gray-400">Current Status for <span class="font-semibold text-white">Your Region</span></p>
              <h2 id="alert-status-text" class="text-2xl font-bold mt-1">Status: Green (Normal)</h2>
            </div>
          </div>
          <div class="mt-4 md:mt-0 text-right">
            <p id="outage-probability" class="text-3xl font-bold">1%</p>
            <p class="text-sm text-gray-400">Predicted Outage Risk</p>
          </div>
        </div>
      </section>

      <section class="mb-8">
        <div class="glass-container p-6 md:p-8">
          <h3 class="text-2xl font-bold mb-4">Recommended Actions</h3>
          <ul id="action-list" class="space-y-4 text-gray-300">
            <li class="flex items-start">
              <span class="text-2xl mr-4 flex-shrink-0">üì±</span>
              <p>
                <strong>Charge devices:</strong> Ensure all critical devices (phone, laptop, power banks) are fully charged.
              </p>
            </li>
            <li class="flex items-start">
              <span class="text-2xl mr-4 flex-shrink-0">üíæ</span>
              <p>
                <strong>Backup critical data:</strong> For important files, consider backing them up to a physical drive or a separate, non-local cloud service.
              </p>
            </li>
            <li class="flex items-start">
              <span class="text-2xl mr-4 flex-shrink-0">üåê</span>
              <p>
                <strong>Delay non-essential activities:</strong> Postpone large file transfers, software updates, or online gaming sessions to avoid potential data loss or connection issues.
              </p>
            </li>
          </ul>
        </div>
      </section>

      <section>
        <div class="glass-container p-6 md:p-8">
          <h3 class="text-2xl font-bold mb-4">Your Recent Alerts</h3>
          <div id="notifications-log" class="space-y-4">
            <div class="bg-gray-800 p-4 rounded-lg">
              <p class="text-lg font-semibold text-yellow-300">‚ö†Ô∏è WARNING: Elevated Outage Risk</p>
              <p class="text-sm text-gray-400 mt-1">Predicted outage probability is at 25% due to a high Kp index and local storm forecast. Prepare for potential communication and power disruption in the next 30-60 minutes.</p>
              <p class="text-xs text-gray-500 mt-2">Sent: 2025-09-23 05:45 AM</p>
            </div>
            <div class="text-center text-gray-500">
              <p>No recent critical alerts.</p>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer id="contact" class="relative py-10 px-6 text-center text-gray-500 bg-transparent z-10">
    <p>¬© 2025 MUON AI. All Rights Reserved.</p>
  </footer>

  <script src="main.js"></script>
  <script>
    // Particle Background Class
    class ParticleBackground {
      constructor() {
        this.canvas = document.getElementById('particleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseRadius = 80;
        this.gridSpacing = 40; // Distance between grid points
        this.init();
      }

      init() {
        this.resize();
        this.createGrid();
        this.animate();
        
        // Event listeners
        window.addEventListener('resize', () => this.resize());
        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        document.addEventListener('click', (e) => this.handleClick(e));
        
        // Touch support for mobile
        document.addEventListener('touchmove', (e) => {
          const touch = e.touches[0];
          this.handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
        });
        
        document.addEventListener('touchstart', (e) => {
          const touch = e.touches[0];
          this.handleClick({ clientX: touch.clientX, clientY: touch.clientY });
        });
      }

      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.createGrid();
      }

      createGrid() {
        this.particles = [];
        const cols = Math.ceil(this.canvas.width / this.gridSpacing);
        const rows = Math.ceil(this.canvas.height / this.gridSpacing);
        
        for (let row = 0; row <= rows; row++) {
          for (let col = 0; col <= cols; col++) {
            const x = col * this.gridSpacing;
            const y = row * this.gridSpacing;
            
            this.particles.push({
              x: x,
              y: y,
              originalX: x,
              originalY: y,
              radius: 1.5,
              color: '#E0E0E0', // Very light white/purple
              hoverGlow: 0,
              clickGlow: 0
            });
          }
        }
      }

      handleMouseMove(e) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        
        // Update hover effects for grid distortion
        this.particles.forEach(particle => {
          const distance = Math.sqrt(
            Math.pow(particle.x - this.mouseX, 2) + 
            Math.pow(particle.y - this.mouseY, 2)
          );
          
          if (distance < this.mouseRadius) {
            const force = (this.mouseRadius - distance) / this.mouseRadius;
            const angle = Math.atan2(particle.y - this.mouseY, particle.x - this.mouseX);
            
            // Repel particles from mouse
            particle.x = particle.originalX + Math.cos(angle) * force * 15;
            particle.y = particle.originalY + Math.sin(angle) * force * 15;
            
            particle.hoverGlow = Math.max(particle.hoverGlow, force * 0.8);
          } else {
            // Return to original position
            particle.x += (particle.originalX - particle.x) * 0.1;
            particle.y += (particle.originalY - particle.y) * 0.1;
            particle.hoverGlow = Math.max(0, particle.hoverGlow - 0.05);
          }
        });
      }

      handleClick(e) {
        // Create subtle click effect
        this.particles.forEach(particle => {
          const distance = Math.sqrt(
            Math.pow(particle.x - e.clientX, 2) + 
            Math.pow(particle.y - e.clientY, 2)
          );
          
          if (distance < 120) {
            const intensity = 1 - (distance / 120);
            particle.clickGlow = Math.max(particle.clickGlow, intensity * 0.6);
          }
        });
      }

      updateParticles() {
        this.particles.forEach(particle => {
          // Fade click glow
          particle.clickGlow = Math.max(0, particle.clickGlow - 0.02);
        });
      }

      drawConnections() {
        const cols = Math.ceil(this.canvas.width / this.gridSpacing);
        const rows = Math.ceil(this.canvas.height / this.gridSpacing);
        
        // Draw horizontal connections
        for (let row = 0; row <= rows; row++) {
          for (let col = 0; col < cols; col++) {
            const index1 = row * (cols + 1) + col;
            const index2 = row * (cols + 1) + col + 1;
            
            if (index1 < this.particles.length && index2 < this.particles.length) {
              const particleA = this.particles[index1];
              const particleB = this.particles[index2];
              
              // Calculate line opacity based on mouse proximity
              const mouseDistance = this.distanceToLine(
                this.mouseX, this.mouseY,
                particleA.x, particleA.y,
                particleB.x, particleB.y
              );
              
              let opacity = 0.15; // Very subtle base opacity
              if (mouseDistance < 40) {
                opacity = Math.max(opacity, 0.4 * (1 - mouseDistance / 40));
              }
              
              this.ctx.strokeStyle = `rgba(224, 224, 224, ${opacity})`;
              this.ctx.lineWidth = 0.5;
              this.ctx.beginPath();
              this.ctx.moveTo(particleA.x, particleA.y);
              this.ctx.lineTo(particleB.x, particleB.y);
              this.ctx.stroke();
            }
          }
        }
        
        // Draw vertical connections
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col <= cols; col++) {
            const index1 = row * (cols + 1) + col;
            const index2 = (row + 1) * (cols + 1) + col;
            
            if (index1 < this.particles.length && index2 < this.particles.length) {
              const particleA = this.particles[index1];
              const particleB = this.particles[index2];
              
              // Calculate line opacity based on mouse proximity
              const mouseDistance = this.distanceToLine(
                this.mouseX, this.mouseY,
                particleA.x, particleA.y,
                particleB.x, particleB.y
              );
              
              let opacity = 0.15; // Very subtle base opacity
              if (mouseDistance < 40) {
                opacity = Math.max(opacity, 0.4 * (1 - mouseDistance / 40));
              }
              
              this.ctx.strokeStyle = `rgba(224, 224, 224, ${opacity})`;
              this.ctx.lineWidth = 0.5;
              this.ctx.beginPath();
              this.ctx.moveTo(particleA.x, particleA.y);
              this.ctx.lineTo(particleB.x, particleB.y);
              this.ctx.stroke();
            }
          }
        }
      }

      distanceToLine(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;
        
        if (lenSq !== 0) param = dot / lenSq;
        
        let xx, yy;
        
        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      drawParticles() {
        this.particles.forEach(particle => {
          // Calculate total glow effect
          const totalGlow = Math.max(particle.hoverGlow, particle.clickGlow);
          
          // Very subtle base opacity
          let opacity = 0.5;
          if (totalGlow > 0) {
            opacity = Math.max(opacity, 0.6 * totalGlow);
          }
          
          this.ctx.fillStyle = `rgba(224, 224, 224, ${opacity})`;
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          this.ctx.fill();
        });
      }

      animate() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.updateParticles();
        this.drawConnections();
        this.drawParticles();
        
        requestAnimationFrame(() => this.animate());
      }
    }

    // Initialize Particle Background
    new ParticleBackground();
  </script>
</body>
</html>